import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# --- System Parameters ---
M = 1.0       # mass of cart (kg)
m = 0.2       # mass of pendulum bob (kg)
l = 1.0       # pendulum length (m)
k = 10.0      # spring constant (N/m)
b = 0.1       # cart damping (NÂ·s/m)
g = 9.81      # gravity (m/s^2)


# --- ODE Definition ---
def F_ext(t, y):
    return 0.0



def rhs(t, y):
    x, x_dot, theta, theta_dot = y
    sin_t = np.sin(theta)
    cos_t = np.cos(theta)
    sin2 = sin_t * sin_t
    denom = M + m * sin2
    if denom == 0.0:
        denom = 1e-8
    num = (m * g * sin_t * cos_t +
           m * l * theta_dot**2 * sin_t -
           k * x +
           F_ext(t, y))
    x_ddot = num / denom
    theta_ddot = -(x_ddot * cos_t + g * sin_t) / l
    return np.array([x_dot, x_ddot, theta_dot, theta_ddot])

# --- Initial Conditions & Timeline ---
x0 = 0.2
x_dot0 = 0.0
theta0 = 20.0 * np.pi/180.0
theta_dot0 = 0.0
y0 = np.array([x0, x_dot0, theta0, theta_dot0])
t_start = 0.0
t_end = 15.0
dt = 0.01
n_steps = int((t_end - t_start) / dt) + 1
t_points = np.linspace(t_start, t_end, n_steps)

# --- Integration Methods ---
y_euler = np.zeros((n_steps, 4))
y_rk2 = np.zeros((n_steps, 4))
y_rk3 = np.zeros((n_steps, 4))
y_rk4 = np.zeros((n_steps, 4))

y_euler[0] = y0
y_rk2[0] = y0
y_rk3[0] = y0
y_rk4[0] = y0

for i in range(n_steps - 1):
    t = t_points[i]
    # Euler
    y_euler[i+1] = y_euler[i] + dt * rhs(t, y_euler[i])
    # RK2
    k1 = rhs(t, y_rk2[i])
    k2 = rhs(t + dt/2, y_rk2[i] + dt/2 * k1)
    y_rk2[i+1] = y_rk2[i] + dt * k2
    # RK3
    k1 = rhs(t, y_rk3[i])
    k2 = rhs(t + dt/2, y_rk3[i] + dt/2 * k1)
    k3 = rhs(t + dt, y_rk3[i] - dt * k1 + 2 * dt * k2)
    y_rk3[i+1] = y_rk3[i] + dt/6 * (k1 + 4*k2 + k3)
    # RK4
    k1 = rhs(t, y_rk4[i])
    k2 = rhs(t + dt/2, y_rk4[i] + dt/2 * k1)
    k3 = rhs(t + dt/2, y_rk4[i] + dt/2 * k2)
    k4 = rhs(t + dt, y_rk4[i] + dt * k3)
    y_rk4[i+1] = y_rk4[i] + dt/6 * (k1 + 2*k2 + 2*k3 + k4)

# --- Extract Variables ---
def unpack_methods(Y):
    x, x_dot, theta, theta_dot = Y[:, 0], Y[:, 1], Y[:, 2], Y[:, 3]
    return x, x_dot, theta, theta_dot
x_euler, x_dot_euler, theta_euler, theta_dot_euler = unpack_methods(y_euler)
x_rk2,   x_dot_rk2,   theta_rk2,   theta_dot_rk2   = unpack_methods(y_rk2)
x_rk3,   x_dot_rk3,   theta_rk3,   theta_dot_rk3   = unpack_methods(y_rk3)
x_rk4,   x_dot_rk4,   theta_rk4,   theta_dot_rk4   = unpack_methods(y_rk4)

# --- Energy ---
def energy(y):
    x, x_dot, theta, theta_dot = y
    vx = x_dot + l * theta_dot * np.cos(theta)
    vy = l * theta_dot * np.sin(theta)
    KE_cart = 0.5 * M * x_dot**2
    KE_pend = 0.5 * m * (vx**2 + vy**2)
    PE_pend = m * g * (l * (1 - np.cos(theta)))
    PE_spring = 0.5 * k * x**2
    return KE_cart + KE_pend + PE_pend + PE_spring

E_euler = np.array([energy(y_euler[i]) for i in range(n_steps)])
E_rk2   = np.array([energy(y_rk2[i])   for i in range(n_steps)])
E_rk3   = np.array([energy(y_rk3[i])   for i in range(n_steps)])
E_rk4   = np.array([energy(y_rk4[i])   for i in range(n_steps)])
